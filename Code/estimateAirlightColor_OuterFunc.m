function [concatenatedColors,individualPairAirlight,pairsWeights] = estimateAirlightColor_OuterFunc(DClessOrAlessChosenPatches,...
    originalStateChosenPatches,overallNNsValidity,t1EstimationChosenPatchesOrNCvals,t2DividedByt1,airlightRecoveryMethod)

estimatedNNsNoiseVar =...
    calculateInterPairsPatchesNoiseVar(DClessOrAlessChosenPatches(:,:,overallNNsValidity,:),...
    t2DividedByt1(:,overallNNsValidity,:),'divideByNormOfAverage');
if nargout>2
    pairsWeights = 1./estimatedNNsNoiseVar;
end
%% Calculating A in one or more ways:
if any(airlightRecoveryMethod==4)
    %% Direct estimation, Without t2DividedByT1:
    wheightsSettingIndex = 1;
    for equationWeights = bsxfun(@eq,airlightRecoveryMethod(airlightRecoveryMethod==3 | airlightRecoveryMethod==4),3)
        estimatedNeighborNoiseVar{1} = ones(1,sum(overallNNsValidity));
        [concatenatedColors(4-equationWeights,:),...
            individualPairAirlight(:,:,4-equationWeights)] =...
            estimateAirlightColor(originalStateChosenPatches(:,:,overallNNsValidity,:),DClessOrAlessChosenPatches(:,:,overallNNsValidity,:),...
            estimatedNeighborNoiseVar,'directWithoutNoise',t1EstimationChosenPatchesOrNCvals);
        wheightsSettingIndex = wheightsSettingIndex+1;
    end
end
if any(airlightRecoveryMethod==6)
    %% Direct estimation, with a noise model, including gradients:
    [concatenatedColors(6,:),...
        individualPairAirlight(:,:,6)] =...
        estimateAirlightColor(originalStateChosenPatches(:,:,overallNNsValidity,:),DClessOrAlessChosenPatches(:,:,overallNNsValidity,:),...
        [],'directWithNoise',t1EstimationChosenPatchesOrNCvals);
end